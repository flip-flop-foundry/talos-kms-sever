# Merged release workflow: on PR merge to main, build debs, create tag/release, then bump main to next minor SNAPSHOT


name: Release on PR merge (build + bump)
## TODO remove synchronize once tested
## TODO remove workflow_dispatch once tested
on:
  pull_request_target:
    types:
      - closed
      - synchronize
    branches:
      - main
      - switchReleaseToBuiltImage
  workflow_dispatch:


permissions:
  contents: write

jobs:
  release_on_pr_merge:
    name: Release when PR merged to main
    runs-on: ubuntu-latest

    if: ((github.event.pull_request != null && github.event.pull_request.merged == true && github.event.pull_request.base.ref == 'main') || github.event_name == 'workflow_dispatch')

    steps:
      - name: Checkout base branch (main)
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.base.ref || github.ref }}
          fetch-depth: 0
          token: ${{ secrets.BOT_TOKEN }}
          persist-credentials: true


      - name: Dump event JSON file
        if: false
        run: |
          cat "$GITHUB_EVENT_PATH"


      - name: Set up QEMU emulation (for multi-arch builds)
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Log in to GHCR
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.BOT_PACKAGES_TOKEN }}

      - name: Restore cached env file
        id: cache-restore
        uses: actions/cache@v4
        with:
          path: .cache/env_vars
          key: ${{ runner.os }}-env-${{ hashFiles('pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-env-

      - name: If cache miss, get Maven project metadata
        id: get_maven_metadata
        if: steps.cache-restore.outputs.cache-hit != 'true'
        run: |
          
          PARAMS=(
          "project.version:MAVEN_VERSION"
          "project.artifactId:APP_NAME"
          "project.description:DESCRIPTION"
          "project.organization.name:VENDOR"
          "project.developers[0].email:MAINTAINER_EMAIL"

          )
          cd ../

          for entry in "${PARAMS[@]}"; do
            IFS=':' read -r EXPR OUT <<< "$entry"
            VALUE=$(mvn -q -DforceStdout help:evaluate -Dexpression="$EXPR" 2>/dev/null || true)
            VALUE=$(echo -n "$VALUE" | tr -d '\r\n')
            echo "Determined $EXPR: $VALUE"
            if [ -z "$VALUE" ]; then
              echo "Could not determine $EXPR via Maven (docker)" >&2
              exit 1
            fi
            mkdir -p .cache
            echo "${OUT}=${VALUE}" >> .cache/env_vars
          done
#          cd buildTools/
#          chmod +x echo-maven-metadata.sh
#          bash echo-maven-metadata.sh

      - name: Load cached env file into GITHUB_ENV
        run: |
          while IFS= read -r line; do
            # handle CRLF if needed:
            line=${line%$'\r'}
            echo "$line" >> $GITHUB_ENV
          done < ".cache/env_vars"

      - name: Save cache (actions/cache uploads at end for misses)
        if: steps.cache-restore.outputs.cache-hit != 'true'
        uses: actions/cache@v4
        with:
          path: .cache/env_vars
          key: ${{ runner.os }}-env-${{ hashFiles('pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-env-

      - name: List envs
        run: |
          env
          

      - name: Set release version (commit to main) before building
        id: set_release
        if: (github.event.pull_request != null && github.event.pull_request.merged == true && github.event.pull_request.base.ref == 'main')
        env:
          BOT_USERNAME: ${{ vars.BOT_USERNAME  }}
          BOT_MAIL: ${{ vars.BOT_MAIL  }}
        run: |
          set -euo pipefail
          CUR=${{ steps.get_maven_metadata.outputs.MAVEN_VERSION }}
          RELEASE=${CUR%-SNAPSHOT}
          echo "release_version=$RELEASE" >> $GITHUB_OUTPUT
          echo "tag=$RELEASE" >> $GITHUB_OUTPUT

          # Use Maven versions plugin to set the release version
          #mvn -q org.codehaus.mojo:versions-maven-plugin:2.14.2:set -DnewVersion="$RELEASE" -DgenerateBackupPoms=false
          docker run --rm -v "$PWD":/workspace -w /workspace ghcr.io/flip-flop-foundry/talos-kms-builder:latest mvn -q org.codehaus.mojo:versions-maven-plugin:2.14.2:set -DnewVersion="$RELEASE" -DgenerateBackupPoms=false

          # Commit and push the release version to main so build operates on the released POM
          git config user.name "$BOT_USERNAME"
          git config user.email "$BOT_MAIL"
          git add pom.xml
          git commit -m "chore(release): set version to $RELEASE [skip ci]" || echo "No changes to commit"
          echo "Set release version $RELEASE for: ${{ github.event.pull_request.base.ref || github.ref }}"
          git push origin HEAD:${{ github.event.pull_request.base.ref || github.ref }}


      - name: Build .deb packages
        run: |
          set -euo pipefail
          chmod +x buildTools/build-deb-in-docker.sh
          bash buildTools/build-deb-in-docker.sh
          echo "Built .deb packages; contents of target/deb-work/output/:"
          exit 1

      - name: Check for existing GitHub Release for this tag
        id: check_release
        run: |
          set -euo pipefail
          TAG=v${{ steps.set_release.outputs.tag }}
          API="https://api.github.com/repos/${GITHUB_REPOSITORY}/releases/tags/${TAG}"
          # Use the BOT_TOKEN when provided (falls back to GITHUB_TOKEN)
          API_TOKEN=${{ secrets.BOT_TOKEN }}
          HTTP_STATUS=$(curl -sSL -o /tmp/release_resp.json -w "%{http_code}" -H "Authorization: Bearer $API_TOKEN" "$API")
          if [ "$HTTP_STATUS" = "200" ]; then
            RELEASE_ID=$(jq -r .id /tmp/release_resp.json)
            UPLOAD_URL=$(jq -r .upload_url /tmp/release_resp.json | sed -e 's/{?name,label}//')
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "release_id=$RELEASE_ID" >> $GITHUB_OUTPUT
            echo "upload_url=$UPLOAD_URL" >> $GITHUB_OUTPUT
            echo "Found existing release ID $RELEASE_ID for tag $TAG"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "No existing release found for tag $TAG"
          fi

      - name: Create and push git tag (if needed)
        if: steps.check_release.outputs.exists != 'true' && (github.event.pull_request != null && github.event.pull_request.merged == true && github.event.pull_request.base.ref == 'main')
        env:
          BOT_USERNAME: ${{ vars.BOT_USERNAME  }}
          BOT_MAIL: ${{ vars.BOT_MAIL  }}
        run: |
          set -euo pipefail
          TAG=v${{ steps.set_release.outputs.tag }}
          git config user.name "$BOT_USERNAME"
          git config user.email "$BOT_MAIL"
          git fetch --prune --tags origin
          if [ -n "$(git ls-remote --tags origin "refs/tags/$TAG")" ]; then
            echo "Tag $TAG already exists on remote; skipping tag creation"
          else
            git tag -a "$TAG" -m "Release $TAG"
            git push origin "$TAG"
            echo "Pushed tag $TAG to origin"
          fi

      - name: Upload debs to existing release (if present)
        if: steps.check_release.outputs.exists == 'true' && (github.event.pull_request != null && github.event.pull_request.merged == true && github.event.pull_request.base.ref == 'main')
        run: |
          set -euo pipefail
          UPLOAD_URL=${{ steps.check_release.outputs.upload_url }}
          API_TOKEN=${{ secrets.BOT_TOKEN }}
          for f in target/deb-work/output/*.deb; do
            if [ -f "$f" ]; then
              echo "Uploading $f to existing release"
              curl -sSL -X POST "$UPLOAD_URL?name=$(basename "$f")" \
                -H "Authorization: Bearer $API_TOKEN" \
                -H "Content-Type: application/octet-stream" \
                --data-binary @"$f" || echo "Warning: upload of $f failed"
            fi
          done

        ## TODO switch to v2
      - name: Create GitHub Release and attach debs (if no existing release)
        if: steps.check_release.outputs.exists != 'true' && (github.event.pull_request != null && github.event.pull_request.merged == true && github.event.pull_request.base.ref == 'main')
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.set_release.outputs.tag }}
          name: v${{ steps.set_release.outputs.tag }}
          files: 'target/deb-work/output/*.deb'
        env:
          GITHUB_TOKEN: ${{ secrets.BOT_TOKEN }}

      - name: Bump main to next minor SNAPSHOT
        id: bump_after_release
        if: (github.event.pull_request != null && github.event.pull_request.merged == true && github.event.pull_request.base.ref == 'main')
        env:
          BOT_USERNAME: ${{ vars.BOT_USERNAME  }}
          BOT_MAIL: ${{ vars.BOT_MAIL  }}
        run: |
          set -euo pipefail

          # Read current version via maven (should reflect the just-committed release version)
          CUR_VER=$(docker run --rm -v "$PWD":/workspace -w /workspace ghcr.io/flip-flop-foundry/talos-kms-builder:latest mvn -q -DforceStdout help:evaluate -Dexpression=project.version 2>/dev/null || true)
          #CUR_VER=$(mvn -q -DforceStdout help:evaluate -Dexpression=project.version 2>/dev/null || true)
          if [ -z "$CUR_VER" ]; then
            echo "Could not determine current version for bump" >&2
            exit 1
          fi
          BASE=${CUR_VER%-SNAPSHOT}
          IFS='.' read -r MAJ MIN REST <<< "$BASE" || true
          MAJ=${MAJ:-0}
          MIN=${MIN:-0}
          NEW_MIN=$((MIN + 1))
          NEW_VERSION="${MAJ}.${NEW_MIN}-SNAPSHOT"

          echo "Setting new project version to $NEW_VERSION"
          #mvn -q org.codehaus.mojo:versions-maven-plugin:2.14.2:set -DnewVersion="$NEW_VERSION" -DgenerateBackupPoms=false
          docker run --rm -v "$PWD":/workspace -w /workspace ghcr.io/flip-flop-foundry/talos-kms-builder:latest mvn -q org.codehaus.mojo:versions-maven-plugin:2.14.2:set -DnewVersion="$NEW_VERSION" -DgenerateBackupPoms=false

          git config user.name "$BOT_USERNAME"
          git config user.email "$BOT_MAIL"
          git add pom.xml
          git commit -m "ci: bump version to $NEW_VERSION [skip ci]" || echo "No changes to commit"

          git push origin HEAD:${{ github.event.pull_request.base.ref || github.ref }}

