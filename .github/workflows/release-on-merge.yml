# Merged release workflow: on PR merge to main, build debs, create tag/release, then bump main to next minor SNAPSHOT
# Extended to support pre-releases (rc/beta/alpha) via PR labels: release:rc, release:beta, release:alpha

name: Build and Release on PR Merge to main
## TODO remove synchronize once tested
## TODO remove workflow_dispatch once tested
on:
  pull_request_target:
    types:
      - closed
      - synchronize
    branches:
      - main
  push:
    branches:
      - addingMatrixToWorkflow
  workflow_dispatch:
    inputs:
      dry_run:
        description: "Run in dry-run mode (no pushes/tags/releases)"
        type: boolean
        default: true
        required: false
      ref:
        description: "Git ref to test from (defaults to PR source branch or selected branch)"
        type: string
        default: ""
        required: false
      pre_id:
        description: "Pre-release id to simulate (none/rc/beta/alpha)"
        type: choice
        options: ["none", "rc", "beta", "alpha"]
        default: "none"
        required: false
      bump_type:
        description: "Final release bump type (major/minor/patch)"
        type: choice
        options: ["minor", "major", "patch"]
        default: "minor"
        required: false

permissions:
  contents: write

concurrency:
  group: release-main
  cancel-in-progress: false

jobs:

  release_prepare:
    name: Prepare & Tag Release
    runs-on: ubuntu-latest
    outputs:
      release_version: ${{ steps.compute.outputs.release_version }}
      tag_name: ${{ steps.compute.outputs.tag_name }}
      checkout_ref: ${{ steps.compute.outputs.checkout_ref }}
      next_dev_version: ${{ steps.compute.outputs.next_dev_version }}
      bump_type: ${{ steps.compute.outputs.bump_type }}
      app_name: ${{ steps.compute.outputs.app_name }}
      description: ${{ steps.compute.outputs.description }}
      vendor: ${{ steps.compute.outputs.vendor }}
      maintainer_email: ${{ steps.compute.outputs.maintainer_email }}
      pre_release: ${{ steps.compute.outputs.pre_release }}
      pre_id: ${{ steps.compute.outputs.pre_id }}
      original_snapshot_version: ${{ steps.compute.outputs.original_snapshot_version }}
      prerelease_branch: ${{ steps.compute.outputs.prerelease_branch }}
      dry_run: ${{ steps.compute.outputs.dry_run }}
    if: >-
      (github.event_name == 'pull_request_target' && github.event.pull_request.merged == true && github.event.pull_request.base.ref == 'main')
      || github.event_name == 'workflow_dispatch'

    steps:
      - name: Checkout base branch (main or input ref)
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event_name == 'workflow_dispatch' && (inputs.ref != '' && inputs.ref || github.event.pull_request.head.ref || github.head_ref || github.ref_name || 'main') || (github.event.pull_request.base.ref || github.ref) }}
          fetch-depth: 0
          token: ${{ secrets.BOT_TOKEN }}
          persist-credentials: true

      - name: Set up git user
        env:
          BOT_USERNAME: ${{ vars.BOT_USERNAME  }}
          BOT_MAIL: ${{ vars.BOT_MAIL  }}
        run: |
          git config user.name "$BOT_USERNAME"
          git config user.email "$BOT_MAIL"

      - name: Restore cached env file
        id: cache-restore
        uses: actions/cache@v4
        with:
          path: .cache/env_vars
          key: ${{ runner.os }}-env-${{ hashFiles('pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-env-

      - name: Gather Maven metadata (pre-bump)
        if: steps.cache-restore.outputs.cache-hit != 'true'
        id: meta
        run: |
          set -euo pipefail
          PARAMS=(
            "project.version:MAVEN_VERSION"
            "project.artifactId:APP_NAME"
            "project.description:DESCRIPTION"
            "project.organization.name:VENDOR"
            "project.developers[0].email:MAINTAINER_EMAIL"
          )
          for entry in "${PARAMS[@]}"; do
            IFS=':' read -r EXPR OUT <<< "$entry"
            VALUE=$(mvn -q -DforceStdout help:evaluate -Dexpression="$EXPR" 2>/dev/null || true)
            VALUE=$(echo -n "$VALUE" | tr -d '\r\n')
            echo "$OUT=$VALUE" >> $GITHUB_ENV
            echo "$OUT=$VALUE"
          
            mkdir -p .cache
            echo "${OUT}=${VALUE}" >> .cache/env_vars
          done
          echo "save-success=true" >> $GITHUB_OUTPUT
          echo "Maven metadata retrieval complete."

      - name: Save cache (actions/cache uploads at end for misses)
        if: steps.get_maven_metadata.outputs.save-success == 'true'
        uses: actions/cache/save@v4
        with:
          path: .cache/env_vars
          key: ${{ runner.os }}-env-${{ hashFiles('pom.xml') }}

      - name: Compute versions, branch and tag (or simulate in dry-run)
        id: compute
        env:
          INPUT_DRY_RUN: ${{ github.event_name == 'workflow_dispatch' && inputs.dry_run || 'false' }}
          INPUT_PRE_ID: ${{ github.event_name == 'workflow_dispatch' && inputs.pre_id || '' }}
          INPUT_BUMP: ${{ github.event_name == 'workflow_dispatch' && inputs.bump_type || '' }}
          INPUT_REF: ${{ github.event_name == 'workflow_dispatch' && (inputs.ref != '' && inputs.ref || github.event.pull_request.head.ref || github.head_ref || github.ref_name || 'main') || '' }}
        run: |
          set -euo pipefail
          CURRENT_VERSION="$MAVEN_VERSION"
          if [ -z "$CURRENT_VERSION" ]; then
            echo "Unable to determine current Maven version" >&2
            exit 1
          fi

          DRY_RUN=false
          if [ "$INPUT_DRY_RUN" = "true" ]; then DRY_RUN=true; fi

          # Default bump type (for final release only)
          BUMP_TYPE=minor
          PRE_ID=""

          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            # Override from inputs
            case "$INPUT_BUMP" in
              major|minor|patch) BUMP_TYPE="$INPUT_BUMP" ;;
            esac
            case "$INPUT_PRE_ID" in
              rc|beta|alpha) PRE_ID="$INPUT_PRE_ID" ;;
              none|"") PRE_ID="" ;;
            esac
          else
            # pull_request_target path: parse labels
            if command -v jq >/dev/null 2>&1; then
              LABELS=$(jq -r '.pull_request.labels[].name' < "$GITHUB_EVENT_PATH" || true)
              echo "PR Labels: $LABELS"
              for l in $LABELS; do
                case "$l" in
                  release:major) BUMP_TYPE=major ;;
                  release:minor) BUMP_TYPE=minor ;;
                  release:patch) BUMP_TYPE=patch ;;
                  release:rc) PRE_ID=rc ;;
                  release:beta) PRE_ID=beta ;;
                  release:alpha) PRE_ID=alpha ;;
                esac
              done
            fi
          fi

          if [[ "$CURRENT_VERSION" != *-SNAPSHOT ]]; then
            echo "Current version ($CURRENT_VERSION) is not a -SNAPSHOT version. Aborting to avoid ambiguous state." >&2
            exit 1
          fi

          ORIGINAL_SNAPSHOT_VERSION="$CURRENT_VERSION"
          BASE_RELEASE_VERSION="${CURRENT_VERSION%-SNAPSHOT}"

          # Normalize to three segments
          IFS='.' read -r MAJ MIN PAT <<< "$BASE_RELEASE_VERSION"
          if [ -z "$MIN" ]; then
            echo "Release version '$BASE_RELEASE_VERSION' does not have a minor segment" >&2; exit 1
          fi
          if [ -z "$PAT" ]; then
            PAT=0
          fi
          NORMALIZED_BASE="${MAJ}.${MIN}.${PAT}"

          PRE_RELEASE=false
          RELEASE_VERSION=""
          TAG_NAME=""
          NEXT_DEV_VERSION=""
          PRERELEASE_BRANCH=""
          CHECKOUT_REF=""

          if [ -n "$PRE_ID" ]; then
            PRE_RELEASE=true
            # Determine next pre-release sequence number from tags (read-only)
            EXISTING=$(git tag -l "v${NORMALIZED_BASE}-${PRE_ID}.*" | sed -E "s/v${NORMALIZED_BASE}-${PRE_ID}\.([0-9]+)/\1/" | sort -n | tail -1 || true)
            if [ -z "$EXISTING" ]; then NEXT_SEQ=1; else NEXT_SEQ=$((EXISTING+1)); fi
            RELEASE_VERSION="${NORMALIZED_BASE}-${PRE_ID}.${NEXT_SEQ}"
            TAG_NAME="v${RELEASE_VERSION}"
            PRERELEASE_BRANCH="prerelease/${NORMALIZED_BASE}-${PRE_ID}"

            if [ "$DRY_RUN" = true ]; then
              echo "[DRY-RUN] Would set version to $RELEASE_VERSION and push to tag $TAG_NAME and branch $PRERELEASE_BRANCH"
              echo "[DRY-RUN] Would act as git user: $(git config user.name) <$(git config user.email)>"
          
              # No push: set local version only so builds match
              mvn -B -ntp versions:set -DnewVersion="$RELEASE_VERSION" -DgenerateBackupPoms=false -DprocessAllModules
              CHECKOUT_REF="${INPUT_REF:-main}"
            else
              echo "Creating/updating prerelease branch $PRERELEASE_BRANCH"
              git checkout -B "$PRERELEASE_BRANCH"
              mvn -B -ntp versions:set -DnewVersion="$RELEASE_VERSION" -DgenerateBackupPoms=false -DprocessAllModules
              git add pom.xml pom.xml || true
              git commit -m "pre-release: cut $TAG_NAME" || { echo "Nothing to commit for prerelease" >&2; exit 1; }
              git tag -a "$TAG_NAME" -m "Pre-release $TAG_NAME"
              git push origin "$PRERELEASE_BRANCH"
              git push origin "$TAG_NAME"
              CHECKOUT_REF="$TAG_NAME"
            fi
          else
            # Final release on main
            RELEASE_VERSION="$NORMALIZED_BASE"
            TAG_NAME="v$RELEASE_VERSION"
            case "$BUMP_TYPE" in
              major) MAJ=$((MAJ+1)); MIN=0; PAT=0 ;;
              minor) MIN=$((MIN+1)); PAT=0 ;;
              patch) PAT=$((PAT+1)) ;;
              *) echo "Unknown bump type: $BUMP_TYPE" >&2; exit 1 ;;
            esac
            NEXT_DEV_VERSION="${MAJ}.${MIN}.${PAT}-SNAPSHOT"

            if [ "$DRY_RUN" = true ]; then
              echo "[DRY-RUN] Would remove -SNAPSHOT, commit release $TAG_NAME, tag and push"
              mvn -B -ntp versions:set -DremoveSnapshot -DgenerateBackupPoms=false -DprocessAllModules
              CHECKOUT_REF="${INPUT_REF:-main}"
            else
              echo "Committing final release $TAG_NAME on main"
              mvn -B -ntp versions:set -DremoveSnapshot -DgenerateBackupPoms=false -DprocessAllModules
              git add pom.xml pom.xml || true
              git commit -m "release: cut $TAG_NAME" || { echo "Nothing to commit for release" >&2; exit 1; }
              git tag -a "$TAG_NAME" -m "Release $TAG_NAME"
              git push origin HEAD:main
              git push origin "$TAG_NAME"
              CHECKOUT_REF="$TAG_NAME"
            fi
          fi

          echo "original_snapshot_version=$ORIGINAL_SNAPSHOT_VERSION" >> $GITHUB_OUTPUT
          echo "release_version=$RELEASE_VERSION" >> $GITHUB_OUTPUT
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "checkout_ref=$CHECKOUT_REF" >> $GITHUB_OUTPUT
          echo "next_dev_version=$NEXT_DEV_VERSION" >> $GITHUB_OUTPUT
          echo "bump_type=$BUMP_TYPE" >> $GITHUB_OUTPUT
          echo "pre_release=$PRE_RELEASE" >> $GITHUB_OUTPUT
          echo "pre_id=$PRE_ID" >> $GITHUB_OUTPUT
          echo "prerelease_branch=$PRERELEASE_BRANCH" >> $GITHUB_OUTPUT
          echo "app_name=$APP_NAME" >> $GITHUB_OUTPUT
          echo "description=$DESCRIPTION" >> $GITHUB_OUTPUT
          echo "vendor=$VENDOR" >> $GITHUB_OUTPUT
          echo "maintainer_email=$MAINTAINER_EMAIL" >> $GITHUB_OUTPUT
          echo "dry_run=$DRY_RUN" >> $GITHUB_OUTPUT

          echo "Version step complete."

  build_jar:
    name: Build JAR file (from tag or ref)
    runs-on: ubuntu-latest
    needs: release_prepare
    outputs:
      jar_name: ${{ steps.build_jar.outputs.jar_name || '' }}
      jar_path: ${{ steps.build_jar.outputs.jar_path || '' }}
    if: needs.release_prepare.outputs.checkout_ref != ''
    steps:
      - name: Checkout ref
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.release_prepare.outputs.checkout_ref }}
          fetch-depth: 0
          token: ${{ secrets.BOT_TOKEN }}
          persist-credentials: true

      - name: Restore cached env file
        id: cache-restore
        uses: actions/cache@v4
        with:
          path: .cache/env_vars
          key: ${{ runner.os }}-env-${{ hashFiles('pom.xml') }}
          fail-on-cache-miss: true

      - name: Load cached env file into GITHUB_ENV
        run: |
          while IFS= read -r line; do
          # handle CRLF if needed:
          line=${line%$'\r'}
          echo "$line" >> $GITHUB_ENV
          done < ".cache/env_vars"

      - name: Load cached maven repository
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-


      - name: Set pom version locally for dry-run
        if: needs.release_prepare.outputs.dry_run == 'true'
        run: |
          set -euo pipefail
          mvn -B -ntp versions:set -DnewVersion="${{ needs.release_prepare.outputs.release_version }}" -DgenerateBackupPoms=false -DprocessAllModules



      - name: Log in to GHCR
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.BOT_PACKAGES_TOKEN }}

      - name: Build .jar file
        id: build_jar
        env:
          APP_NAME: ${{ needs.release_prepare.outputs.app_name }}
          MAVEN_VERSION: ${{ needs.release_prepare.outputs.release_version }}
        run: |
          set -euo pipefail
          chmod +x buildTools/build-jar.sh
          bash buildTools/build-jar.sh

      - name: Upload jar artifact
        uses: actions/upload-artifact@v4
        with:
          name: built-jar
          path: target/jar-build/output/*.jar
          if-no-files-found: error
          retention-days: 7
          overwrite: true

  build_debs:
    name: Build DEB for architectures (from tag or ref)
    runs-on: ubuntu-latest
    needs: build_jar
    strategy:
      matrix:
        arch: [amd64, arm64]
    if: needs.build_jar.outputs.jar_name != ''
    steps:
      - name: Checkout ref
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.release_prepare.outputs.checkout_ref }}
          fetch-depth: 0
          token: ${{ secrets.BOT_TOKEN }}
          persist-credentials: true

      - name: Restore cached env file
        id: cache-restore
        uses: actions/cache@v4
        with:
          path: .cache/env_vars
          key: ${{ runner.os }}-env-${{ hashFiles('pom.xml') }}
          fail-on-cache-miss: true

      - name: Load cached env file into GITHUB_ENV
        run: |
          while IFS= read -r line; do
          # handle CRLF if needed:
          line=${line%$'\r'}
          echo "$line" >> $GITHUB_ENV
          done < ".cache/env_vars"

      - name: Set up QEMU emulation (for multi-arch builds)
        uses: docker/setup-qemu-action@v2

      - name: Download built jar artifact
        uses: actions/download-artifact@v5
        with:
          name: built-jar
          path: target/deb-work/input

      - name: Log in to GHCR
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.BOT_PACKAGES_TOKEN }}

      - name: Build deb file for ${{ matrix.arch }}
        env:
          JAR_NAME: ${{ needs.build_jar.outputs.jar_name || '' }}
          ARCH: ${{ matrix.arch }}
        run: |
          set -euo pipefail
          chmod +x buildTools/build-deb.sh
          bash buildTools/build-deb.sh

      - name: Upload deb artifact
        uses: actions/upload-artifact@v4
        with:
          name: built-deb-${{ matrix.arch }}
          path: target/deb-work/artifacts/*.deb
          if-no-files-found: error
          retention-days: 7
          overwrite: true

  create_github_release:
    name: Create GitHub Release & Upload Assets
    runs-on: ubuntu-latest
    needs: [release_prepare, build_debs]
    if: needs.release_prepare.outputs.tag_name != '' && needs.build_debs.result == 'success' && needs.release_prepare.outputs.dry_run != 'true'
    steps:
      - name: Download jar artifact
        uses: actions/download-artifact@v5
        with:
          name: built-jar
          path: release-assets

      - name: Download deb amd64
        uses: actions/download-artifact@v5
        with:
          name: built-deb-amd64
          path: release-assets

      - name: Download deb arm64
        uses: actions/download-artifact@v5
        with:
          name: built-deb-arm64
          path: release-assets

      - name: List assets
        run: ls -lh release-assets

      - name: Create GitHub Release
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ needs.release_prepare.outputs.tag_name }}
          name: Release ${{ needs.release_prepare.outputs.tag_name }}
          body: |
            Automated release for ${{ needs.release_prepare.outputs.tag_name }}
            Pre-release: ${{ needs.release_prepare.outputs.pre_release }}
            Pre-id: ${{ needs.release_prepare.outputs.pre_id }}
            Bump type (final only): ${{ needs.release_prepare.outputs.bump_type }}
            Description: ${{ needs.release_prepare.outputs.description }}
          artifacts: "release-assets/*.jar,release-assets/*.deb"
          token: ${{ secrets.BOT_TOKEN }}
          draft: false
          allowUpdates: false
          prerelease: ${{ needs.release_prepare.outputs.pre_release == 'true' }}

  post_release_bump:
    name: Bump to next development version
    runs-on: ubuntu-latest
    needs: [release_prepare, build_debs, create_github_release]
    if: >-
      always() &&
      needs.release_prepare.outputs.next_dev_version != '' &&
      needs.release_prepare.outputs.pre_release == 'false' &&
      needs.release_prepare.outputs.dry_run != 'true' &&
      needs.build_debs.result == 'success' &&
      needs.create_github_release.result == 'success'
    steps:
      - name: Checkout main (includes release commit)
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0
          token: ${{ secrets.BOT_TOKEN }}
          persist-credentials: true

      - name: Configure git user
        env:
          BOT_USERNAME: ${{ vars.BOT_USERNAME  }}
          BOT_MAIL: ${{ vars.BOT_MAIL  }}
        run: |
          git config user.name "$BOT_USERNAME"
          git config user.email "$BOT_MAIL"

      - name: Validate current pom matches release version
        run: |
          set -euo pipefail
          CURRENT=$(mvn -q -DforceStdout help:evaluate -Dexpression=project.version 2>/dev/null || true)
          if [ "$CURRENT" != "${{ needs.release_prepare.outputs.release_version }}" ]; then
            echo "Main branch pom version ($CURRENT) does not match release version (${{ needs.release_prepare.outputs.release_version }}). Aborting dev bump." >&2
            exit 1
          fi

      - name: Set next development version
        run: |
          set -euo pipefail
          NEXT="${{ needs.release_prepare.outputs.next_dev_version }}"
          mvn -B -ntp versions:set -DnewVersion="$NEXT" -DgenerateBackupPoms=false -DprocessAllModules
          git add pom.xml pom.xml || true
          if git diff --cached --quiet; then
            echo "No version change detected when setting next dev version $NEXT" >&2
            exit 1
          fi
          git commit -m "chore(release): start $NEXT"
          git push origin HEAD:main
          echo "Bumped to $NEXT"

