# Merged release workflow: on PR merge to main, build debs, create tag/release, then bump main to next minor SNAPSHOT
# Extended to support pre-releases (rc/beta/alpha) via PR labels: release:rc, release:beta, release:alpha

name: Build and Release on PR Merge to main
## TODO remove synchronize once tested
## TODO remove workflow_dispatch once tested
on:
  pull_request_target:
    types:
      - closed
      - synchronize
    branches:
      - main
  push:
    branches:
      - addingMatrixToWorkflow
  workflow_dispatch:

permissions:
  contents: write

concurrency:
  group: release-main
  cancel-in-progress: false

jobs:

  release_prepare:
    name: Prepare & Tag Release
    runs-on: ubuntu-latest
    outputs:
      release_version: ${{ steps.compute.outputs.release_version }}
      tag_name: ${{ steps.compute.outputs.tag_name }}
      next_dev_version: ${{ steps.compute.outputs.next_dev_version }}
      bump_type: ${{ steps.compute.outputs.bump_type }}
      app_name: ${{ steps.compute.outputs.app_name }}
      description: ${{ steps.compute.outputs.description }}
      vendor: ${{ steps.compute.outputs.vendor }}
      maintainer_email: ${{ steps.compute.outputs.maintainer_email }}
      pre_release: ${{ steps.compute.outputs.pre_release }}
      pre_id: ${{ steps.compute.outputs.pre_id }}
      original_snapshot_version: ${{ steps.compute.outputs.original_snapshot_version }}
      prerelease_branch: ${{ steps.compute.outputs.prerelease_branch }}
    if: >-
      (github.event_name == 'pull_request_target' && github.event.pull_request.merged == true && github.event.pull_request.base.ref == 'main')
      || github.event_name == 'workflow_dispatch'

    steps:
      - name: Checkout base branch (main)
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.base.ref || github.ref }}
          fetch-depth: 0
          token: ${{ secrets.BOT_TOKEN }}
          BOT_USERNAME: ${{ vars.BOT_USERNAME  }}
          BOT_MAIL: ${{ vars.BOT_MAIL  }}
          persist-credentials: true

      - name: Set up git user
        run: |
          git config user.name "$BOT_USERNAME"
          git config user.email "$BOT_MAIL"

      - name: Gather Maven metadata (pre-bump)
        id: meta
        run: |
          set -euo pipefail
          PARAMS=(
            "project.version:MAVEN_VERSION"
            "project.artifactId:APP_NAME"
            "project.description:DESCRIPTION"
            "project.organization.name:VENDOR"
            "project.developers[0].email:MAINTAINER_EMAIL"
          )
          for entry in "${PARAMS[@]}"; do
            IFS=':' read -r EXPR OUT <<< "$entry"
            VALUE=$(mvn -q -DforceStdout help:evaluate -Dexpression="$EXPR" 2>/dev/null || true)
            VALUE=$(echo -n "$VALUE" | tr -d '\r\n')
            echo "$OUT=$VALUE" >> $GITHUB_ENV
            echo "$OUT=$VALUE"
          done

      - name: Compute versions, branch and tag
        id: compute
        run: |
          set -euo pipefail
          CURRENT_VERSION="$MAVEN_VERSION"
          if [ -z "$CURRENT_VERSION" ]; then
            echo "Unable to determine current Maven version" >&2
            exit 1
          fi

          # Default bump type (for final release only)
          BUMP_TYPE=minor
          PRE_ID=""
          if [ "${{ github.event_name }}" = "pull_request_target" ]; then
            if command -v jq >/dev/null 2>&1; then
              LABELS=$(jq -r '.pull_request.labels[].name' < "$GITHUB_EVENT_PATH" || true)
              echo "PR Labels: $LABELS"
              for l in $LABELS; do
                case "$l" in
                  release:major) BUMP_TYPE=major ;;
                  release:minor) BUMP_TYPE=minor ;;
                  release:patch) BUMP_TYPE=patch ;;
                  release:rc) PRE_ID=rc ;;
                  release:beta) PRE_ID=beta ;;
                  release:alpha) PRE_ID=alpha ;;
                esac
              done
            fi
          fi

          if [[ "$CURRENT_VERSION" != *-SNAPSHOT ]]; then
            echo "Current version ($CURRENT_VERSION) is not a -SNAPSHOT version. Aborting to avoid ambiguous state." >&2
            exit 1
          fi

          ORIGINAL_SNAPSHOT_VERSION="$CURRENT_VERSION"
          BASE_RELEASE_VERSION="${CURRENT_VERSION%-SNAPSHOT}"

          # Normalize to three segments
          IFS='.' read -r MAJ MIN PAT <<< "$BASE_RELEASE_VERSION"
          if [ -z "$MIN" ]; then
            echo "Release version '$BASE_RELEASE_VERSION' does not have a minor segment" >&2; exit 1
          fi
          if [ -z "$PAT" ]; then
            PAT=0
          fi
          NORMALIZED_BASE="${MAJ}.${MIN}.${PAT}"

          PRE_RELEASE=false
          RELEASE_VERSION=""
          TAG_NAME=""
          NEXT_DEV_VERSION=""
          PRERELEASE_BRANCH=""

          if [ -n "$PRE_ID" ]; then
            PRE_RELEASE=true
            # Determine next pre-release sequence number from tags
            EXISTING=$(git tag -l "v${NORMALIZED_BASE}-${PRE_ID}.*" | sed -E "s/v${NORMALIZED_BASE}-${PRE_ID}\.([0-9]+)/\1/" | sort -n | tail -1 || true)
            if [ -z "$EXISTING" ]; then NEXT_SEQ=1; else NEXT_SEQ=$((EXISTING+1)); fi
            RELEASE_VERSION="${NORMALIZED_BASE}-${PRE_ID}.${NEXT_SEQ}"
            TAG_NAME="v${RELEASE_VERSION}"
            PRERELEASE_BRANCH="prerelease/${NORMALIZED_BASE}-${PRE_ID}"

            echo "Creating/updating prerelease branch $PRERELEASE_BRANCH"
            git checkout -B "$PRERELEASE_BRANCH"
            mvn -B -ntp versions:set -DnewVersion="$RELEASE_VERSION" -DgenerateBackupPoms=false -DprocessAllModules
            git add pom.xml */*/pom.xml || true
            git commit -m "pre-release: cut $TAG_NAME" || { echo "Nothing to commit for prerelease" >&2; exit 1; }
            git tag -a "$TAG_NAME" -m "Pre-release $TAG_NAME"
            git push origin "$PRERELEASE_BRANCH"
            git push origin "$TAG_NAME"
          else
            # Final release on main
            RELEASE_VERSION="$NORMALIZED_BASE"
            TAG_NAME="v$RELEASE_VERSION"
            case "$BUMP_TYPE" in
              major) MAJ=$((MAJ+1)); MIN=0; PAT=0 ;;
              minor) MIN=$((MIN+1)); PAT=0 ;;
              patch) PAT=$((PAT+1)) ;;
              *) echo "Unknown bump type: $BUMP_TYPE" >&2; exit 1 ;;
            esac
            NEXT_DEV_VERSION="${MAJ}.${MIN}.${PAT}-SNAPSHOT"

            echo "Committing final release $TAG_NAME on main"
            mvn -B -ntp versions:set -DremoveSnapshot -DgenerateBackupPoms=false -DprocessAllModules
            git add pom.xml */*/pom.xml || true
            git commit -m "release: cut $TAG_NAME" || { echo "Nothing to commit for release" >&2; exit 1; }
            git tag -a "$TAG_NAME" -m "Release $TAG_NAME"
            git push origin HEAD:main
            git push origin "$TAG_NAME"
          fi

          echo "original_snapshot_version=$ORIGINAL_SNAPSHOT_VERSION" >> $GITHUB_OUTPUT
          echo "release_version=$RELEASE_VERSION" >> $GITHUB_OUTPUT
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "next_dev_version=$NEXT_DEV_VERSION" >> $GITHUB_OUTPUT
          echo "bump_type=$BUMP_TYPE" >> $GITHUB_OUTPUT
          echo "pre_release=$PRE_RELEASE" >> $GITHUB_OUTPUT
          echo "pre_id=$PRE_ID" >> $GITHUB_OUTPUT
          echo "prerelease_branch=$PRERELEASE_BRANCH" >> $GITHUB_OUTPUT
          echo "app_name=$APP_NAME" >> $GITHUB_OUTPUT
          echo "description=$DESCRIPTION" >> $GITHUB_OUTPUT
          echo "vendor=$VENDOR" >> $GITHUB_OUTPUT
          echo "maintainer_email=$MAINTAINER_EMAIL" >> $GITHUB_OUTPUT

          echo "Version commit and tag created."

  build_jar:
    name: Build JAR file (from tag)
    runs-on: ubuntu-latest
    needs: release_prepare
    outputs:
      jar_name: ${{ steps.build_jar.outputs.jar_name || '' }}
      jar_path: ${{ steps.build_jar.outputs.jar_path || '' }}
    if: needs.release_prepare.outputs.tag_name != ''
    steps:
      - name: Checkout release tag
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.release_prepare.outputs.tag_name }}
          fetch-depth: 0
          token: ${{ secrets.BOT_TOKEN }}
          persist-credentials: true

      - name: Retrieve Maven metadata from tag
        run: |
          set -euo pipefail
          PARAMS=(
            "project.version:MAVEN_VERSION"
            "project.artifactId:APP_NAME"
            "project.description:DESCRIPTION"
            "project.organization.name:VENDOR"
            "project.developers[0].email:MAINTAINER_EMAIL"
          )
          for entry in "${PARAMS[@]}"; do
            IFS=':' read -r EXPR OUT <<< "$entry"
            VALUE=$(mvn -q -DforceStdout help:evaluate -Dexpression="$EXPR" 2>/dev/null || true)
            VALUE=$(echo -n "$VALUE" | tr -d '\r\n')
            echo "$OUT=$VALUE" >> $GITHUB_ENV
            echo "$OUT=$VALUE"
          done

      - name: Load cached maven repository
        uses: actions/cache@v4
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-

      - name: Log in to GHCR
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.BOT_PACKAGES_TOKEN }}

      - name: Build .jar file
        id: build_jar
        env:
          APP_NAME: ${{ needs.release_prepare.outputs.app_name }}
          MAVEN_VERSION: ${{ needs.release_prepare.outputs.release_version }}
        run: |
          set -euo pipefail
          chmod +x buildTools/build-jar.sh
          bash buildTools/build-jar.sh

      - name: Upload jar artifact
        uses: actions/upload-artifact@v4
        with:
          name: built-jar
          path: target/jar-build/output/*.jar
          if-no-files-found: error
          retention-days: 7
          overwrite: true

  build_debs:
    name: Build DEB for architectures (from tag)
    runs-on: ubuntu-latest
    needs: build_jar
    strategy:
      matrix:
        arch: [amd64, arm64]
    if: needs.build_jar.outputs.jar_name != ''
    steps:
      - name: Checkout release tag
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.release_prepare.outputs.tag_name }}
          fetch-depth: 0
          token: ${{ secrets.BOT_TOKEN }}
          persist-credentials: true

      - name: Retrieve Maven metadata from tag
        run: |
          set -euo pipefail
          PARAMS=(
            "project.version:MAVEN_VERSION"
            "project.artifactId:APP_NAME"
            "project.description:DESCRIPTION"
            "project.organization.name:VENDOR"
            "project.developers[0].email:MAINTAINER_EMAIL"
          )
          for entry in "${PARAMS[@]}"; do
            IFS=':' read -r EXPR OUT <<< "$entry"
            VALUE=$(mvn -q -DforceStdout help:evaluate -Dexpression="$EXPR" 2>/dev/null || true)
            VALUE=$(echo -n "$VALUE" | tr -d '\r\n')
            echo "$OUT=$VALUE" >> $GITHUB_ENV
            echo "$OUT=$VALUE"
          done

      - name: Set up QEMU emulation (for multi-arch builds)
        uses: docker/setup-qemu-action@v2

      - name: Download built jar artifact
        uses: actions/download-artifact@v5
        with:
          name: built-jar
          path: target/deb-work/input

      - name: Log in to GHCR
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.BOT_PACKAGES_TOKEN }}

      - name: Build deb file for ${{ matrix.arch }}
        env:
          JAR_NAME: ${{ needs.build_jar.outputs.jar_name || '' }}
          ARCH: ${{ matrix.arch }}
        run: |
          set -euo pipefail
          chmod +x buildTools/build-deb.sh
          bash buildTools/build-deb.sh

      - name: Upload deb artifact
        uses: actions/upload-artifact@v4
        with:
          name: built-deb-${{ matrix.arch }}
          path: target/deb-work/artifacts/*.deb
          if-no-files-found: error
          retention-days: 7
          overwrite: true

  create_github_release:
    name: Create GitHub Release & Upload Assets
    runs-on: ubuntu-latest
    needs: [release_prepare, build_debs]
    if: needs.release_prepare.outputs.tag_name != '' && needs.build_debs.result == 'success'
    steps:
      - name: Download jar artifact
        uses: actions/download-artifact@v5
        with:
          name: built-jar
          path: release-assets

      - name: Download deb amd64
        uses: actions/download-artifact@v5
        with:
          name: built-deb-amd64
          path: release-assets

      - name: Download deb arm64
        uses: actions/download-artifact@v5
        with:
          name: built-deb-arm64
          path: release-assets

      - name: List assets
        run: ls -lh release-assets

      - name: Create GitHub Release
        uses: ncipollo/release-action@v1
        with:
          tag: ${{ needs.release_prepare.outputs.tag_name }}
          name: Release ${{ needs.release_prepare.outputs.tag_name }}
          body: |
            Automated release for ${{ needs.release_prepare.outputs.tag_name }}
            Pre-release: ${{ needs.release_prepare.outputs.pre_release }}
            Pre-id: ${{ needs.release_prepare.outputs.pre_id }}
            Bump type (final only): ${{ needs.release_prepare.outputs.bump_type }}
            Description: ${{ needs.release_prepare.outputs.description }}
          artifacts: "release-assets/*.jar,release-assets/*.deb"
          token: ${{ secrets.BOT_TOKEN }}
          draft: false
          allowUpdates: false
          prerelease: ${{ needs.release_prepare.outputs.pre_release == 'true' }}

  post_release_bump:
    name: Bump to next development version
    runs-on: ubuntu-latest
    needs: [release_prepare, build_debs, create_github_release]
    if: >-
      always() &&
      needs.release_prepare.outputs.next_dev_version != '' &&
      needs.release_prepare.outputs.pre_release == 'false' &&
      needs.build_debs.result == 'success' &&
      needs.create_github_release.result == 'success'
    steps:
      - name: Checkout main (includes release commit)
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0
          token: ${{ secrets.BOT_TOKEN }}
          BOT_USERNAME: ${{ vars.BOT_USERNAME  }}
          BOT_MAIL: ${{ vars.BOT_MAIL  }}
          persist-credentials: true

      - name: Configure git user
        run: |
          git config user.name "$BOT_USERNAME"
          git config user.email "$BOT_MAIL"

      - name: Validate current pom matches release version
        run: |
          set -euo pipefail
          CURRENT=$(mvn -q -DforceStdout help:evaluate -Dexpression=project.version 2>/dev/null || true)
          if [ "$CURRENT" != "${{ needs.release_prepare.outputs.release_version }}" ]; then
            echo "Main branch pom version ($CURRENT) does not match release version (${{ needs.release_prepare.outputs.release_version }}). Aborting dev bump." >&2
            exit 1
          fi

      - name: Set next development version
        run: |
          set -euo pipefail
          NEXT="${{ needs.release_prepare.outputs.next_dev_version }}"
          mvn -B -ntp versions:set -DnewVersion="$NEXT" -DgenerateBackupPoms=false -DprocessAllModules
          git add pom.xml */*/pom.xml || true
          if git diff --cached --quiet; then
            echo "No version change detected when setting next dev version $NEXT" >&2
            exit 1
          fi
          git commit -m "chore(release): start $NEXT"
          git push origin HEAD:main
          echo "Bumped to $NEXT"

